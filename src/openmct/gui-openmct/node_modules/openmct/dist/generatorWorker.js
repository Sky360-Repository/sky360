!function(g,I){"object"==typeof exports&&"object"==typeof module?module.exports=I():"function"==typeof define&&define.amd?define([],I):"object"==typeof exports?exports.openmct=I():g.openmct=I()}(this,(function(){return(()=>{var __webpack_modules__={260:()=>{eval("/*****************************************************************************\n * Open MCT, Copyright (c) 2014-2022, United States Government\n * as represented by the Administrator of the National Aeronautics and Space\n * Administration. All rights reserved.\n *\n * Open MCT is licensed under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n *\n * Open MCT includes source code licensed under additional open source\n * licenses. See the Open Source Licenses file (LICENSES.md) included with\n * this source code distribution or the Licensing information page available\n * at runtime from the About dialog for additional information.\n *****************************************************************************/\n\n(function () {\n\n    var FIFTEEN_MINUTES = 15 * 60 * 1000;\n\n    var handlers = {\n        subscribe: onSubscribe,\n        unsubscribe: onUnsubscribe,\n        request: onRequest\n    };\n\n    var subscriptions = {};\n\n    function workSubscriptions(timestamp) {\n        var now = Date.now();\n        var nextWork = Math.min.apply(Math, Object.values(subscriptions).map(function (subscription) {\n            return subscription(now);\n        }));\n        var wait = nextWork - now;\n        if (wait < 0) {\n            wait = 0;\n        }\n\n        if (Number.isFinite(wait)) {\n            setTimeout(workSubscriptions, wait);\n        }\n    }\n\n    function onSubscribe(message) {\n        var data = message.data;\n\n        // Keep\n        var start = Date.now();\n        var step = 1000 / data.dataRateInHz;\n        var nextStep = start - (start % step) + step;\n        let work;\n        if (data.spectra) {\n            work = function (now) {\n                while (nextStep < now) {\n                    const messageCopy = Object.create(message);\n                    message.data.start = nextStep - (60 * 1000);\n                    message.data.end = nextStep;\n                    onRequest(messageCopy);\n                    nextStep += step;\n                }\n\n                return nextStep;\n            };\n        } else {\n            work = function (now) {\n                while (nextStep < now) {\n                    self.postMessage({\n                        id: message.id,\n                        data: {\n                            name: data.name,\n                            utc: nextStep,\n                            yesterday: nextStep - 60 * 60 * 24 * 1000,\n                            sin: sin(nextStep, data.period, data.amplitude, data.offset, data.phase, data.randomness),\n                            wavelengths: wavelengths(),\n                            intensities: intensities(),\n                            cos: cos(nextStep, data.period, data.amplitude, data.offset, data.phase, data.randomness)\n                        }\n                    });\n                    nextStep += step;\n                }\n\n                return nextStep;\n            };\n        }\n\n        subscriptions[message.id] = work;\n        workSubscriptions();\n    }\n\n    function onUnsubscribe(message) {\n        delete subscriptions[message.data.id];\n    }\n\n    function onRequest(message) {\n        var request = message.data;\n        if (request.end === undefined) {\n            request.end = Date.now();\n        }\n\n        if (request.start === undefined) {\n            request.start = request.end - FIFTEEN_MINUTES;\n        }\n\n        var now = Date.now();\n        var start = request.start;\n        var end = request.end > now ? now : request.end;\n        var amplitude = request.amplitude;\n        var period = request.period;\n        var offset = request.offset;\n        var dataRateInHz = request.dataRateInHz;\n        var phase = request.phase;\n        var randomness = request.randomness;\n        var loadDelay = Math.max(request.loadDelay, 0);\n\n        var step = 1000 / dataRateInHz;\n        var nextStep = start - (start % step) + step;\n\n        var data = [];\n\n        for (; nextStep < end && data.length < 5000; nextStep += step) {\n            data.push({\n                utc: nextStep,\n                yesterday: nextStep - 60 * 60 * 24 * 1000,\n                sin: sin(nextStep, period, amplitude, offset, phase, randomness),\n                wavelengths: wavelengths(),\n                intensities: intensities(),\n                cos: cos(nextStep, period, amplitude, offset, phase, randomness)\n            });\n        }\n\n        if (loadDelay === 0) {\n            postOnRequest(message, request, data);\n        } else {\n            setTimeout(() => postOnRequest(message, request, data), loadDelay);\n        }\n    }\n\n    function postOnRequest(message, request, data) {\n        self.postMessage({\n            id: message.id,\n            data: request.spectra ? {\n                wavelength: data.map((item) => {\n                    return item.wavelength;\n                }),\n                cos: data.map((item) => {\n                    return item.cos;\n                })\n            } : data\n        });\n    }\n\n    function cos(timestamp, period, amplitude, offset, phase, randomness) {\n        return amplitude\n            * Math.cos(phase + (timestamp / period / 1000 * Math.PI * 2)) + (amplitude * Math.random() * randomness) + offset;\n    }\n\n    function sin(timestamp, period, amplitude, offset, phase, randomness) {\n        return amplitude\n            * Math.sin(phase + (timestamp / period / 1000 * Math.PI * 2)) + (amplitude * Math.random() * randomness) + offset;\n    }\n\n    function wavelengths() {\n        let values = [];\n        while (values.length < 5) {\n            const randomValue = Math.random() * 100;\n            if (!values.includes(randomValue)) {\n                values.push(String(randomValue));\n            }\n        }\n\n        return values;\n    }\n\n    function intensities() {\n        let values = [];\n        while (values.length < 5) {\n            const randomValue = Math.random() * 10;\n            if (!values.includes(randomValue)) {\n                values.push(String(randomValue));\n            }\n        }\n\n        return values;\n    }\n\n    function sendError(error, message) {\n        self.postMessage({\n            error: error.name + ': ' + error.message,\n            message: message,\n            id: message.id\n        });\n    }\n\n    self.onmessage = function handleMessage(event) {\n        var message = event.data;\n        var handler = handlers[message.request];\n\n        if (!handler) {\n            sendError(new Error('unknown message type'), message);\n        } else {\n            try {\n                handler(message);\n            } catch (e) {\n                sendError(e, message);\n            }\n        }\n    };\n\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYwLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsc0NBQXNDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5tY3QvLi9leGFtcGxlL2dlbmVyYXRvci9nZW5lcmF0b3JXb3JrZXIuanM/OWUxZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE9wZW4gTUNULCBDb3B5cmlnaHQgKGMpIDIwMTQtMjAyMiwgVW5pdGVkIFN0YXRlcyBHb3Zlcm5tZW50XG4gKiBhcyByZXByZXNlbnRlZCBieSB0aGUgQWRtaW5pc3RyYXRvciBvZiB0aGUgTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlXG4gKiBBZG1pbmlzdHJhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBPcGVuIE1DVCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAuXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUXG4gKiBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGVcbiAqIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBPcGVuIE1DVCBpbmNsdWRlcyBzb3VyY2UgY29kZSBsaWNlbnNlZCB1bmRlciBhZGRpdGlvbmFsIG9wZW4gc291cmNlXG4gKiBsaWNlbnNlcy4gU2VlIHRoZSBPcGVuIFNvdXJjZSBMaWNlbnNlcyBmaWxlIChMSUNFTlNFUy5tZCkgaW5jbHVkZWQgd2l0aFxuICogdGhpcyBzb3VyY2UgY29kZSBkaXN0cmlidXRpb24gb3IgdGhlIExpY2Vuc2luZyBpbmZvcm1hdGlvbiBwYWdlIGF2YWlsYWJsZVxuICogYXQgcnVudGltZSBmcm9tIHRoZSBBYm91dCBkaWFsb2cgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgRklGVEVFTl9NSU5VVEVTID0gMTUgKiA2MCAqIDEwMDA7XG5cbiAgICB2YXIgaGFuZGxlcnMgPSB7XG4gICAgICAgIHN1YnNjcmliZTogb25TdWJzY3JpYmUsXG4gICAgICAgIHVuc3Vic2NyaWJlOiBvblVuc3Vic2NyaWJlLFxuICAgICAgICByZXF1ZXN0OiBvblJlcXVlc3RcbiAgICB9O1xuXG4gICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHdvcmtTdWJzY3JpcHRpb25zKHRpbWVzdGFtcCkge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIG5leHRXb3JrID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgT2JqZWN0LnZhbHVlcyhzdWJzY3JpcHRpb25zKS5tYXAoZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbihub3cpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciB3YWl0ID0gbmV4dFdvcmsgLSBub3c7XG4gICAgICAgIGlmICh3YWl0IDwgMCkge1xuICAgICAgICAgICAgd2FpdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHdhaXQpKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHdvcmtTdWJzY3JpcHRpb25zLCB3YWl0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uU3Vic2NyaWJlKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtZXNzYWdlLmRhdGE7XG5cbiAgICAgICAgLy8gS2VlcFxuICAgICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgc3RlcCA9IDEwMDAgLyBkYXRhLmRhdGFSYXRlSW5IejtcbiAgICAgICAgdmFyIG5leHRTdGVwID0gc3RhcnQgLSAoc3RhcnQgJSBzdGVwKSArIHN0ZXA7XG4gICAgICAgIGxldCB3b3JrO1xuICAgICAgICBpZiAoZGF0YS5zcGVjdHJhKSB7XG4gICAgICAgICAgICB3b3JrID0gZnVuY3Rpb24gKG5vdykge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0U3RlcCA8IG5vdykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlQ29weSA9IE9iamVjdC5jcmVhdGUobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YS5zdGFydCA9IG5leHRTdGVwIC0gKDYwICogMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YS5lbmQgPSBuZXh0U3RlcDtcbiAgICAgICAgICAgICAgICAgICAgb25SZXF1ZXN0KG1lc3NhZ2VDb3B5KTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0ZXAgKz0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFN0ZXA7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29yayA9IGZ1bmN0aW9uIChub3cpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dFN0ZXAgPCBub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbWVzc2FnZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRjOiBuZXh0U3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ZXN0ZXJkYXk6IG5leHRTdGVwIC0gNjAgKiA2MCAqIDI0ICogMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW46IHNpbihuZXh0U3RlcCwgZGF0YS5wZXJpb2QsIGRhdGEuYW1wbGl0dWRlLCBkYXRhLm9mZnNldCwgZGF0YS5waGFzZSwgZGF0YS5yYW5kb21uZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXZlbGVuZ3Roczogd2F2ZWxlbmd0aHMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlbnNpdGllczogaW50ZW5zaXRpZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3M6IGNvcyhuZXh0U3RlcCwgZGF0YS5wZXJpb2QsIGRhdGEuYW1wbGl0dWRlLCBkYXRhLm9mZnNldCwgZGF0YS5waGFzZSwgZGF0YS5yYW5kb21uZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0ZXAgKz0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFN0ZXA7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc3Vic2NyaXB0aW9uc1ttZXNzYWdlLmlkXSA9IHdvcms7XG4gICAgICAgIHdvcmtTdWJzY3JpcHRpb25zKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25VbnN1YnNjcmliZShtZXNzYWdlKSB7XG4gICAgICAgIGRlbGV0ZSBzdWJzY3JpcHRpb25zW21lc3NhZ2UuZGF0YS5pZF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25SZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgIGlmIChyZXF1ZXN0LmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmVuZCA9IERhdGUubm93KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWVzdC5zdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnN0YXJ0ID0gcmVxdWVzdC5lbmQgLSBGSUZURUVOX01JTlVURVM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmVxdWVzdC5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHJlcXVlc3QuZW5kID4gbm93ID8gbm93IDogcmVxdWVzdC5lbmQ7XG4gICAgICAgIHZhciBhbXBsaXR1ZGUgPSByZXF1ZXN0LmFtcGxpdHVkZTtcbiAgICAgICAgdmFyIHBlcmlvZCA9IHJlcXVlc3QucGVyaW9kO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcmVxdWVzdC5vZmZzZXQ7XG4gICAgICAgIHZhciBkYXRhUmF0ZUluSHogPSByZXF1ZXN0LmRhdGFSYXRlSW5IejtcbiAgICAgICAgdmFyIHBoYXNlID0gcmVxdWVzdC5waGFzZTtcbiAgICAgICAgdmFyIHJhbmRvbW5lc3MgPSByZXF1ZXN0LnJhbmRvbW5lc3M7XG4gICAgICAgIHZhciBsb2FkRGVsYXkgPSBNYXRoLm1heChyZXF1ZXN0LmxvYWREZWxheSwgMCk7XG5cbiAgICAgICAgdmFyIHN0ZXAgPSAxMDAwIC8gZGF0YVJhdGVJbkh6O1xuICAgICAgICB2YXIgbmV4dFN0ZXAgPSBzdGFydCAtIChzdGFydCAlIHN0ZXApICsgc3RlcDtcblxuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuXG4gICAgICAgIGZvciAoOyBuZXh0U3RlcCA8IGVuZCAmJiBkYXRhLmxlbmd0aCA8IDUwMDA7IG5leHRTdGVwICs9IHN0ZXApIHtcbiAgICAgICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgdXRjOiBuZXh0U3RlcCxcbiAgICAgICAgICAgICAgICB5ZXN0ZXJkYXk6IG5leHRTdGVwIC0gNjAgKiA2MCAqIDI0ICogMTAwMCxcbiAgICAgICAgICAgICAgICBzaW46IHNpbihuZXh0U3RlcCwgcGVyaW9kLCBhbXBsaXR1ZGUsIG9mZnNldCwgcGhhc2UsIHJhbmRvbW5lc3MpLFxuICAgICAgICAgICAgICAgIHdhdmVsZW5ndGhzOiB3YXZlbGVuZ3RocygpLFxuICAgICAgICAgICAgICAgIGludGVuc2l0aWVzOiBpbnRlbnNpdGllcygpLFxuICAgICAgICAgICAgICAgIGNvczogY29zKG5leHRTdGVwLCBwZXJpb2QsIGFtcGxpdHVkZSwgb2Zmc2V0LCBwaGFzZSwgcmFuZG9tbmVzcylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvYWREZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgcG9zdE9uUmVxdWVzdChtZXNzYWdlLCByZXF1ZXN0LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcG9zdE9uUmVxdWVzdChtZXNzYWdlLCByZXF1ZXN0LCBkYXRhKSwgbG9hZERlbGF5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3RPblJlcXVlc3QobWVzc2FnZSwgcmVxdWVzdCwgZGF0YSkge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGlkOiBtZXNzYWdlLmlkLFxuICAgICAgICAgICAgZGF0YTogcmVxdWVzdC5zcGVjdHJhID8ge1xuICAgICAgICAgICAgICAgIHdhdmVsZW5ndGg6IGRhdGEubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLndhdmVsZW5ndGg7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY29zOiBkYXRhLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5jb3M7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gOiBkYXRhXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvcyh0aW1lc3RhbXAsIHBlcmlvZCwgYW1wbGl0dWRlLCBvZmZzZXQsIHBoYXNlLCByYW5kb21uZXNzKSB7XG4gICAgICAgIHJldHVybiBhbXBsaXR1ZGVcbiAgICAgICAgICAgICogTWF0aC5jb3MocGhhc2UgKyAodGltZXN0YW1wIC8gcGVyaW9kIC8gMTAwMCAqIE1hdGguUEkgKiAyKSkgKyAoYW1wbGl0dWRlICogTWF0aC5yYW5kb20oKSAqIHJhbmRvbW5lc3MpICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNpbih0aW1lc3RhbXAsIHBlcmlvZCwgYW1wbGl0dWRlLCBvZmZzZXQsIHBoYXNlLCByYW5kb21uZXNzKSB7XG4gICAgICAgIHJldHVybiBhbXBsaXR1ZGVcbiAgICAgICAgICAgICogTWF0aC5zaW4ocGhhc2UgKyAodGltZXN0YW1wIC8gcGVyaW9kIC8gMTAwMCAqIE1hdGguUEkgKiAyKSkgKyAoYW1wbGl0dWRlICogTWF0aC5yYW5kb20oKSAqIHJhbmRvbW5lc3MpICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhdmVsZW5ndGhzKCkge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgY29uc3QgcmFuZG9tVmFsdWUgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZXMuaW5jbHVkZXMocmFuZG9tVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goU3RyaW5nKHJhbmRvbVZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludGVuc2l0aWVzKCkge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgY29uc3QgcmFuZG9tVmFsdWUgPSBNYXRoLnJhbmRvbSgpICogMTA7XG4gICAgICAgICAgICBpZiAoIXZhbHVlcy5pbmNsdWRlcyhyYW5kb21WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChTdHJpbmcocmFuZG9tVmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VuZEVycm9yKGVycm9yLCBtZXNzYWdlKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLm5hbWUgKyAnOiAnICsgZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICBpZDogbWVzc2FnZS5pZFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzW21lc3NhZ2UucmVxdWVzdF07XG5cbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICBzZW5kRXJyb3IobmV3IEVycm9yKCd1bmtub3duIG1lc3NhZ2UgdHlwZScpLCBtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcihtZXNzYWdlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzZW5kRXJyb3IoZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG59KCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///260\n")}},__webpack_exports__={};return __webpack_modules__[260](),__webpack_exports__})()}));