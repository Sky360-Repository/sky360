!function(g,I){"object"==typeof exports&&"object"==typeof module?module.exports=I():"function"==typeof define&&define.amd?define([],I):"object"==typeof exports?exports.openmct=I():g.openmct=I()}(this,(function(){return(()=>{var __webpack_modules__={8897:()=>{eval("/*****************************************************************************\n * Open MCT, Copyright (c) 2014-2022, United States Government\n * as represented by the Administrator of the National Aeronautics and Space\n * Administration. All rights reserved.\n *\n * Open MCT is licensed under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n *\n * Open MCT includes source code licensed under additional open source\n * licenses. See the Open Source Licenses file (LICENSES.md) included with\n * this source code distribution or the Licensing information page available\n * at runtime from the About dialog for additional information.\n *****************************************************************************/\n\n/**\n * Module defining InMemorySearchWorker. Created by deeptailor on 10/03/2019.\n */\n(function () {\n    // An object composed of domain object IDs and models\n    // {id: domainObject's ID, name: domainObject's name}\n    const indexedDomainObjects = {};\n    const indexedAnnotationsByDomainObject = {};\n    const indexedAnnotationsByTag = {};\n\n    self.onconnect = function (e) {\n        const port = e.ports[0];\n\n        port.onmessage = function (event) {\n            const requestType = event.data.request;\n            if (requestType === 'index') {\n                indexItem(event.data.keyString, event.data.model);\n            } else if (requestType === 'OBJECTS') {\n                port.postMessage(searchForObjects(event.data));\n            } else if (requestType === 'ANNOTATIONS') {\n                port.postMessage(searchForAnnotations(event.data));\n            } else if (requestType === 'TAGS') {\n                port.postMessage(searchForTags(event.data));\n            } else if (requestType === 'NOTEBOOK_ANNOTATIONS') {\n                port.postMessage(searchForNotebookAnnotations(event.data));\n            } else {\n                throw new Error(`Unknown request ${event.data.request}`);\n            }\n        };\n\n        port.start();\n\n    };\n\n    self.onerror = function (error) {\n        //do nothing\n        console.error('Error on feed', error);\n    };\n\n    function indexAnnotation(objectToIndex, model) {\n        Object.keys(model.targets).forEach(targetID => {\n            if (!indexedAnnotationsByDomainObject[targetID]) {\n                indexedAnnotationsByDomainObject[targetID] = [];\n            }\n\n            objectToIndex.targets = model.targets;\n            objectToIndex.tags = model.tags;\n            const existsInIndex = indexedAnnotationsByDomainObject[targetID].some(indexedObject => {\n                return indexedObject.keyString === objectToIndex.keyString;\n            });\n\n            if (!existsInIndex) {\n                indexedAnnotationsByDomainObject[targetID].push(objectToIndex);\n            }\n        });\n    }\n\n    function indexTags(keyString, objectToIndex, model) {\n        // add new tags\n        model.tags.forEach(tagID => {\n            if (!indexedAnnotationsByTag[tagID]) {\n                indexedAnnotationsByTag[tagID] = [];\n            }\n\n            const existsInIndex = indexedAnnotationsByTag[tagID].some(indexedObject => {\n                return indexedObject.keyString === objectToIndex.keyString;\n            });\n\n            if (!existsInIndex) {\n                indexedAnnotationsByTag[tagID].push(objectToIndex);\n            }\n\n        });\n        // remove old tags\n        const tagsToRemoveFromIndex = Object.keys(indexedAnnotationsByTag).filter(indexedTag => {\n            return !(model.tags.includes(indexedTag));\n        });\n        tagsToRemoveFromIndex.forEach(tagToRemoveFromIndex => {\n            indexedAnnotationsByTag[tagToRemoveFromIndex] = indexedAnnotationsByTag[tagToRemoveFromIndex].filter(indexedAnnotation => {\n                const shouldKeep = indexedAnnotation.keyString !== keyString;\n\n                return shouldKeep;\n            });\n        });\n    }\n\n    function indexItem(keyString, model) {\n        const objectToIndex = {\n            type: model.type,\n            name: model.name,\n            keyString\n        };\n        if (model && (model.type === 'annotation')) {\n            if (model.targets) {\n                indexAnnotation(objectToIndex, model);\n            }\n\n            if (model.tags) {\n                indexTags(keyString, objectToIndex, model);\n            }\n        } else {\n            indexedDomainObjects[keyString] = objectToIndex;\n        }\n    }\n\n    /**\n     * Gets search results from the indexedItems based on provided search\n     *   input. Returns matching results from indexedItems\n     *\n     * @param data An object which contains:\n     *           * input: The original string which we are searching with\n     *           * maxResults: The maximum number of search results desired\n     *           * queryId: an id identifying this query, will be returned.\n     */\n    function searchForObjects(data) {\n        let results = [];\n        const input = data.input.trim().toLowerCase();\n        const message = {\n            request: 'searchForObjects',\n            results: [],\n            total: 0,\n            queryId: data.queryId\n        };\n\n        results = Object.values(indexedDomainObjects).filter((indexedItem) => {\n            return indexedItem.name.toLowerCase().includes(input);\n        }) || [];\n\n        message.total = results.length;\n        message.results = results\n            .slice(0, data.maxResults);\n\n        return message;\n    }\n\n    function searchForAnnotations(data) {\n        let results = [];\n        const message = {\n            request: 'searchForAnnotations',\n            results: [],\n            total: 0,\n            queryId: data.queryId\n        };\n\n        results = indexedAnnotationsByDomainObject[data.input] || [];\n\n        message.total = results.length;\n        message.results = results\n            .slice(0, data.maxResults);\n\n        return message;\n    }\n\n    function searchForTags(data) {\n        let results = [];\n        const message = {\n            request: 'searchForTags',\n            results: [],\n            total: 0,\n            queryId: data.queryId\n        };\n\n        if (data.input) {\n            data.input.forEach(matchingTag => {\n                const matchingAnnotations = indexedAnnotationsByTag[matchingTag];\n                if (matchingAnnotations) {\n                    matchingAnnotations.forEach(matchingAnnotation => {\n                        const existsInResults = results.some(indexedObject => {\n                            return matchingAnnotation.keyString === indexedObject.keyString;\n                        });\n                        if (!existsInResults) {\n                            results.push(matchingAnnotation);\n                        }\n                    });\n                }\n            });\n        }\n\n        message.total = results.length;\n        message.results = results\n            .slice(0, data.maxResults);\n\n        return message;\n    }\n\n    function searchForNotebookAnnotations(data) {\n        let results = [];\n        const message = {\n            request: 'searchForNotebookAnnotations',\n            results: {},\n            total: 0,\n            queryId: data.queryId\n        };\n\n        const matchingAnnotations = indexedAnnotationsByDomainObject[data.input.targetKeyString];\n        if (matchingAnnotations) {\n            results = matchingAnnotations.filter(matchingAnnotation => {\n                if (!matchingAnnotation.targets) {\n                    return false;\n                }\n\n                const target = matchingAnnotation.targets[data.input.targetKeyString];\n\n                return (target && target.entryId && (target.entryId === data.input.entryId));\n            });\n        }\n\n        message.total = results.length;\n        message.results = results\n            .slice(0, data.maxResults);\n\n        return message;\n    }\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODg5Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkLG1EQUFtRCxtQkFBbUI7QUFDdEU7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5tY3QvLi9zcmMvYXBpL29iamVjdHMvSW5NZW1vcnlTZWFyY2hXb3JrZXIuanM/MmMxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE9wZW4gTUNULCBDb3B5cmlnaHQgKGMpIDIwMTQtMjAyMiwgVW5pdGVkIFN0YXRlcyBHb3Zlcm5tZW50XG4gKiBhcyByZXByZXNlbnRlZCBieSB0aGUgQWRtaW5pc3RyYXRvciBvZiB0aGUgTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlXG4gKiBBZG1pbmlzdHJhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBPcGVuIE1DVCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAuXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUXG4gKiBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGVcbiAqIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBPcGVuIE1DVCBpbmNsdWRlcyBzb3VyY2UgY29kZSBsaWNlbnNlZCB1bmRlciBhZGRpdGlvbmFsIG9wZW4gc291cmNlXG4gKiBsaWNlbnNlcy4gU2VlIHRoZSBPcGVuIFNvdXJjZSBMaWNlbnNlcyBmaWxlIChMSUNFTlNFUy5tZCkgaW5jbHVkZWQgd2l0aFxuICogdGhpcyBzb3VyY2UgY29kZSBkaXN0cmlidXRpb24gb3IgdGhlIExpY2Vuc2luZyBpbmZvcm1hdGlvbiBwYWdlIGF2YWlsYWJsZVxuICogYXQgcnVudGltZSBmcm9tIHRoZSBBYm91dCBkaWFsb2cgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogTW9kdWxlIGRlZmluaW5nIEluTWVtb3J5U2VhcmNoV29ya2VyLiBDcmVhdGVkIGJ5IGRlZXB0YWlsb3Igb24gMTAvMDMvMjAxOS5cbiAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBbiBvYmplY3QgY29tcG9zZWQgb2YgZG9tYWluIG9iamVjdCBJRHMgYW5kIG1vZGVsc1xuICAgIC8vIHtpZDogZG9tYWluT2JqZWN0J3MgSUQsIG5hbWU6IGRvbWFpbk9iamVjdCdzIG5hbWV9XG4gICAgY29uc3QgaW5kZXhlZERvbWFpbk9iamVjdHMgPSB7fTtcbiAgICBjb25zdCBpbmRleGVkQW5ub3RhdGlvbnNCeURvbWFpbk9iamVjdCA9IHt9O1xuICAgIGNvbnN0IGluZGV4ZWRBbm5vdGF0aW9uc0J5VGFnID0ge307XG5cbiAgICBzZWxmLm9uY29ubmVjdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGNvbnN0IHBvcnQgPSBlLnBvcnRzWzBdO1xuXG4gICAgICAgIHBvcnQub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0VHlwZSA9IGV2ZW50LmRhdGEucmVxdWVzdDtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0VHlwZSA9PT0gJ2luZGV4Jykge1xuICAgICAgICAgICAgICAgIGluZGV4SXRlbShldmVudC5kYXRhLmtleVN0cmluZywgZXZlbnQuZGF0YS5tb2RlbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlcXVlc3RUeXBlID09PSAnT0JKRUNUUycpIHtcbiAgICAgICAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKHNlYXJjaEZvck9iamVjdHMoZXZlbnQuZGF0YSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0VHlwZSA9PT0gJ0FOTk9UQVRJT05TJykge1xuICAgICAgICAgICAgICAgIHBvcnQucG9zdE1lc3NhZ2Uoc2VhcmNoRm9yQW5ub3RhdGlvbnMoZXZlbnQuZGF0YSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0VHlwZSA9PT0gJ1RBR1MnKSB7XG4gICAgICAgICAgICAgICAgcG9ydC5wb3N0TWVzc2FnZShzZWFyY2hGb3JUYWdzKGV2ZW50LmRhdGEpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdFR5cGUgPT09ICdOT1RFQk9PS19BTk5PVEFUSU9OUycpIHtcbiAgICAgICAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKHNlYXJjaEZvck5vdGVib29rQW5ub3RhdGlvbnMoZXZlbnQuZGF0YSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcmVxdWVzdCAke2V2ZW50LmRhdGEucmVxdWVzdH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBwb3J0LnN0YXJ0KCk7XG5cbiAgICB9O1xuXG4gICAgc2VsZi5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIC8vZG8gbm90aGluZ1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBvbiBmZWVkJywgZXJyb3IpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbmRleEFubm90YXRpb24ob2JqZWN0VG9JbmRleCwgbW9kZWwpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobW9kZWwudGFyZ2V0cykuZm9yRWFjaCh0YXJnZXRJRCA9PiB7XG4gICAgICAgICAgICBpZiAoIWluZGV4ZWRBbm5vdGF0aW9uc0J5RG9tYWluT2JqZWN0W3RhcmdldElEXSkge1xuICAgICAgICAgICAgICAgIGluZGV4ZWRBbm5vdGF0aW9uc0J5RG9tYWluT2JqZWN0W3RhcmdldElEXSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmplY3RUb0luZGV4LnRhcmdldHMgPSBtb2RlbC50YXJnZXRzO1xuICAgICAgICAgICAgb2JqZWN0VG9JbmRleC50YWdzID0gbW9kZWwudGFncztcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0c0luSW5kZXggPSBpbmRleGVkQW5ub3RhdGlvbnNCeURvbWFpbk9iamVjdFt0YXJnZXRJRF0uc29tZShpbmRleGVkT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhlZE9iamVjdC5rZXlTdHJpbmcgPT09IG9iamVjdFRvSW5kZXgua2V5U3RyaW5nO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghZXhpc3RzSW5JbmRleCkge1xuICAgICAgICAgICAgICAgIGluZGV4ZWRBbm5vdGF0aW9uc0J5RG9tYWluT2JqZWN0W3RhcmdldElEXS5wdXNoKG9iamVjdFRvSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmRleFRhZ3Moa2V5U3RyaW5nLCBvYmplY3RUb0luZGV4LCBtb2RlbCkge1xuICAgICAgICAvLyBhZGQgbmV3IHRhZ3NcbiAgICAgICAgbW9kZWwudGFncy5mb3JFYWNoKHRhZ0lEID0+IHtcbiAgICAgICAgICAgIGlmICghaW5kZXhlZEFubm90YXRpb25zQnlUYWdbdGFnSURdKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZEFubm90YXRpb25zQnlUYWdbdGFnSURdID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGV4aXN0c0luSW5kZXggPSBpbmRleGVkQW5ub3RhdGlvbnNCeVRhZ1t0YWdJRF0uc29tZShpbmRleGVkT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhlZE9iamVjdC5rZXlTdHJpbmcgPT09IG9iamVjdFRvSW5kZXgua2V5U3RyaW5nO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghZXhpc3RzSW5JbmRleCkge1xuICAgICAgICAgICAgICAgIGluZGV4ZWRBbm5vdGF0aW9uc0J5VGFnW3RhZ0lEXS5wdXNoKG9iamVjdFRvSW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZW1vdmUgb2xkIHRhZ3NcbiAgICAgICAgY29uc3QgdGFnc1RvUmVtb3ZlRnJvbUluZGV4ID0gT2JqZWN0LmtleXMoaW5kZXhlZEFubm90YXRpb25zQnlUYWcpLmZpbHRlcihpbmRleGVkVGFnID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhKG1vZGVsLnRhZ3MuaW5jbHVkZXMoaW5kZXhlZFRhZykpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGFnc1RvUmVtb3ZlRnJvbUluZGV4LmZvckVhY2godGFnVG9SZW1vdmVGcm9tSW5kZXggPT4ge1xuICAgICAgICAgICAgaW5kZXhlZEFubm90YXRpb25zQnlUYWdbdGFnVG9SZW1vdmVGcm9tSW5kZXhdID0gaW5kZXhlZEFubm90YXRpb25zQnlUYWdbdGFnVG9SZW1vdmVGcm9tSW5kZXhdLmZpbHRlcihpbmRleGVkQW5ub3RhdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkS2VlcCA9IGluZGV4ZWRBbm5vdGF0aW9uLmtleVN0cmluZyAhPT0ga2V5U3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNob3VsZEtlZXA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kZXhJdGVtKGtleVN0cmluZywgbW9kZWwpIHtcbiAgICAgICAgY29uc3Qgb2JqZWN0VG9JbmRleCA9IHtcbiAgICAgICAgICAgIHR5cGU6IG1vZGVsLnR5cGUsXG4gICAgICAgICAgICBuYW1lOiBtb2RlbC5uYW1lLFxuICAgICAgICAgICAga2V5U3RyaW5nXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtb2RlbCAmJiAobW9kZWwudHlwZSA9PT0gJ2Fubm90YXRpb24nKSkge1xuICAgICAgICAgICAgaWYgKG1vZGVsLnRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICBpbmRleEFubm90YXRpb24ob2JqZWN0VG9JbmRleCwgbW9kZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobW9kZWwudGFncykge1xuICAgICAgICAgICAgICAgIGluZGV4VGFncyhrZXlTdHJpbmcsIG9iamVjdFRvSW5kZXgsIG1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ZWREb21haW5PYmplY3RzW2tleVN0cmluZ10gPSBvYmplY3RUb0luZGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBzZWFyY2ggcmVzdWx0cyBmcm9tIHRoZSBpbmRleGVkSXRlbXMgYmFzZWQgb24gcHJvdmlkZWQgc2VhcmNoXG4gICAgICogICBpbnB1dC4gUmV0dXJucyBtYXRjaGluZyByZXN1bHRzIGZyb20gaW5kZXhlZEl0ZW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBBbiBvYmplY3Qgd2hpY2ggY29udGFpbnM6XG4gICAgICogICAgICAgICAgICogaW5wdXQ6IFRoZSBvcmlnaW5hbCBzdHJpbmcgd2hpY2ggd2UgYXJlIHNlYXJjaGluZyB3aXRoXG4gICAgICogICAgICAgICAgICogbWF4UmVzdWx0czogVGhlIG1heGltdW0gbnVtYmVyIG9mIHNlYXJjaCByZXN1bHRzIGRlc2lyZWRcbiAgICAgKiAgICAgICAgICAgKiBxdWVyeUlkOiBhbiBpZCBpZGVudGlmeWluZyB0aGlzIHF1ZXJ5LCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlYXJjaEZvck9iamVjdHMoZGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBpbnB1dCA9IGRhdGEuaW5wdXQudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICByZXF1ZXN0OiAnc2VhcmNoRm9yT2JqZWN0cycsXG4gICAgICAgICAgICByZXN1bHRzOiBbXSxcbiAgICAgICAgICAgIHRvdGFsOiAwLFxuICAgICAgICAgICAgcXVlcnlJZDogZGF0YS5xdWVyeUlkXG4gICAgICAgIH07XG5cbiAgICAgICAgcmVzdWx0cyA9IE9iamVjdC52YWx1ZXMoaW5kZXhlZERvbWFpbk9iamVjdHMpLmZpbHRlcigoaW5kZXhlZEl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleGVkSXRlbS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoaW5wdXQpO1xuICAgICAgICB9KSB8fCBbXTtcblxuICAgICAgICBtZXNzYWdlLnRvdGFsID0gcmVzdWx0cy5sZW5ndGg7XG4gICAgICAgIG1lc3NhZ2UucmVzdWx0cyA9IHJlc3VsdHNcbiAgICAgICAgICAgIC5zbGljZSgwLCBkYXRhLm1heFJlc3VsdHMpO1xuXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlYXJjaEZvckFubm90YXRpb25zKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHJlcXVlc3Q6ICdzZWFyY2hGb3JBbm5vdGF0aW9ucycsXG4gICAgICAgICAgICByZXN1bHRzOiBbXSxcbiAgICAgICAgICAgIHRvdGFsOiAwLFxuICAgICAgICAgICAgcXVlcnlJZDogZGF0YS5xdWVyeUlkXG4gICAgICAgIH07XG5cbiAgICAgICAgcmVzdWx0cyA9IGluZGV4ZWRBbm5vdGF0aW9uc0J5RG9tYWluT2JqZWN0W2RhdGEuaW5wdXRdIHx8IFtdO1xuXG4gICAgICAgIG1lc3NhZ2UudG90YWwgPSByZXN1bHRzLmxlbmd0aDtcbiAgICAgICAgbWVzc2FnZS5yZXN1bHRzID0gcmVzdWx0c1xuICAgICAgICAgICAgLnNsaWNlKDAsIGRhdGEubWF4UmVzdWx0cyk7XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VhcmNoRm9yVGFncyhkYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICByZXF1ZXN0OiAnc2VhcmNoRm9yVGFncycsXG4gICAgICAgICAgICByZXN1bHRzOiBbXSxcbiAgICAgICAgICAgIHRvdGFsOiAwLFxuICAgICAgICAgICAgcXVlcnlJZDogZGF0YS5xdWVyeUlkXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRhdGEuaW5wdXQpIHtcbiAgICAgICAgICAgIGRhdGEuaW5wdXQuZm9yRWFjaChtYXRjaGluZ1RhZyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdBbm5vdGF0aW9ucyA9IGluZGV4ZWRBbm5vdGF0aW9uc0J5VGFnW21hdGNoaW5nVGFnXTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdBbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZ0Fubm90YXRpb25zLmZvckVhY2gobWF0Y2hpbmdBbm5vdGF0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0c0luUmVzdWx0cyA9IHJlc3VsdHMuc29tZShpbmRleGVkT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdBbm5vdGF0aW9uLmtleVN0cmluZyA9PT0gaW5kZXhlZE9iamVjdC5rZXlTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RzSW5SZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG1hdGNoaW5nQW5ub3RhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVzc2FnZS50b3RhbCA9IHJlc3VsdHMubGVuZ3RoO1xuICAgICAgICBtZXNzYWdlLnJlc3VsdHMgPSByZXN1bHRzXG4gICAgICAgICAgICAuc2xpY2UoMCwgZGF0YS5tYXhSZXN1bHRzKTtcblxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWFyY2hGb3JOb3RlYm9va0Fubm90YXRpb25zKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHJlcXVlc3Q6ICdzZWFyY2hGb3JOb3RlYm9va0Fubm90YXRpb25zJyxcbiAgICAgICAgICAgIHJlc3VsdHM6IHt9LFxuICAgICAgICAgICAgdG90YWw6IDAsXG4gICAgICAgICAgICBxdWVyeUlkOiBkYXRhLnF1ZXJ5SWRcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBtYXRjaGluZ0Fubm90YXRpb25zID0gaW5kZXhlZEFubm90YXRpb25zQnlEb21haW5PYmplY3RbZGF0YS5pbnB1dC50YXJnZXRLZXlTdHJpbmddO1xuICAgICAgICBpZiAobWF0Y2hpbmdBbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgcmVzdWx0cyA9IG1hdGNoaW5nQW5ub3RhdGlvbnMuZmlsdGVyKG1hdGNoaW5nQW5ub3RhdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGluZ0Fubm90YXRpb24udGFyZ2V0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gbWF0Y2hpbmdBbm5vdGF0aW9uLnRhcmdldHNbZGF0YS5pbnB1dC50YXJnZXRLZXlTdHJpbmddO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0YXJnZXQgJiYgdGFyZ2V0LmVudHJ5SWQgJiYgKHRhcmdldC5lbnRyeUlkID09PSBkYXRhLmlucHV0LmVudHJ5SWQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVzc2FnZS50b3RhbCA9IHJlc3VsdHMubGVuZ3RoO1xuICAgICAgICBtZXNzYWdlLnJlc3VsdHMgPSByZXN1bHRzXG4gICAgICAgICAgICAuc2xpY2UoMCwgZGF0YS5tYXhSZXN1bHRzKTtcblxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG59KCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8897\n")}},__webpack_exports__={};return __webpack_modules__[8897](),__webpack_exports__})()}));